---
title: "Advent of Code 2015: Rust setup"
date: 2022-06-01T14:14:42.987Z
draft: false
featured: false
image:
  filename: featured
  focal_point: Smart
  preview_only: false
---
Let's get our repo set up for the Rust side of our project.

The astute reader may have noticed that I've titled this post "setup" and not "boilerplate". This is because our setup will obviate the need for boilerplate! Honestly it's quite similar to the code generation setup Go uses, except it's using a Rust _build script_, which does not place the generated source in the repo like our Go generator does.

## Cargo

`cargo` is Rust's first-class build and dependency manager. One _can_ run the Rust compiler individually, but it generally doesn't make sense to. The first thing we are going to do is run `cargo new aoc2015` to make our package. This creates a simple hello world application with the necessary files. In particular, we're interested in `Cargo.toml`. Here's what the generated file looks like:

```toml {linenos=table}
[package]
name = "aoc2015"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
```

This file includes our package metadata and list of dependencies. While Rust does have a good standard library, it does not cover as much functionality as the Go standard library so we will need to use some external dependencies. We are going to immediately add to this file to include a few dependencies (which we'll cover in a bit):

```toml {linenos=table}
[package]
name = "aoc2015"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
simple-error = "0.2"

[build-dependencies]
tinytemplate = "1"
serde = { version = "1.0", features = ["derive"] }
```

We've added `simple-error`to our dependencies, and also added a new `build-dependencies` section with `tinytemplate` and `serde`. For the former two, we've used a simplified value which is just a version number. This behaves as a `*.x`, so for `simple-error` the latest `0.2.x` version will be retrieved, for tinytemplate the latest `1.x` version. This allows you to pin to the extent you feel is appropriate.

We'll discuss what each of these dependencies is for as we encounter them.

## src/main.rs

The other file generated by `cargo new` is `src/main.rs`. This is exactly what you think it might be: the entrypoint for the program. We're going to replace the contents of this file as follows:

```rust {linenos=table}
use simple_error::SimpleError;
use std::env;
use std::error::Error;

fn main() -> Result<(), Box<dyn Error>> {
    let args = env::args().collect::<Vec<String>>();
    if let Some(path) = args.get(1) {
        return aoc2015::run_all(path);
    }
    Err(Box::new(SimpleError::new("No input path provided")))
}
```

Let's break this down.

```rust {linenos=table,linenostart=1}
use simple_error::SimpleError;
use std::env;
use std::error::Error;
```

The preamble to our file has our imports. Rust has a set of imports called the _prelude_ which are imported into every file. Anything one wishes to use that is not in the prelude must be imported. For our entrypoint, we are using:
* the `env` module from the `std` crate. `std` contains the Rust standard library, while `env` contains functions to inspect the process environment;
* the `Error` trait from the `error` module in `std`. `error` only contains `Error`, which is a _trait_ that any type must implement to be treated as an error.
* the `SimpleError` type from the `simple_error` crate, which is an implementation of the `Error` trait on the `String` type. We'll use this (as well as some of the supporting _macros_) throughout our implementations, since we are generally looking to report any errors as text. Notice that `simple_error` corresponds to the `simple-error` dependency we added to `Cargo.toml`.

```rust {linenos=table,linenostart=5}
fn main() -> Result<(), Box<dyn Error>> {
```

This is the function declaration for our `main` function, which like C and Go is the entrypoint for the program. Spelled out, this line defines a function `main` that has no arguments, and returns a `Result<(), Box<dyn Error>>`

The `Result` type is very commonly used in Rust. It is a _generic enum_, and is more correctly noted as `Result<T,E>`. Rust `enum`s are very powerful, as one can assign values of arbitrary types to them. The `Result<T, E>` enum has two variants: `Ok(T)` and Err(E)`. `T` and `E` have no bounds, and thus can be satisfied by any type. In our case, our `Ok` variant is the Rust `unit` type `()`, and our `Err` variant is `Box<dyn Error>`, which is simply speaking a heap-allocated container for any type which implements the `Error` trait. We'll see how we use these in just a bit.

```rust {linenos=table,linenostart=6}
    let args = env::args().collect::<Vec<String>>();
```

This line retrieves the command line arguments and `collect`s them into a `Vec<String>`. `env::args()` returns an _iterator_, rather than a collection. Using `collect`, we can consume the iterator to create a function of the specified type. The `::<>` syntax is colloquially called the _turbofish_, and is not frequently used â€“ only where the types cannot be inferred by the compiler.

`Vec` is the dynamically-allocated growable array type provided by the Rust standard library. We use this instead of a nominal array because we don't know how many arguments will be provided at compile time.

```rust {linenos=table,linenostart=7}
    if let Some(path) = args.get(1) {
        return aoc2015::run_all(path);
    }
    Err(Box::new(SimpleError::new("No input path provided")))
}
```

This stanza retrieves the path argument from the provided command and calls the top level `run_all` (yet to be defined) function from our crate using the argument if it is provided. `args.get()` returns a `Option` `enum`, which is similar to the `Result` enum we just discussed. `Option` has two variants: `None` and `Some(T)`, where `T` has no bounds. `if let` is a shorthand construct for checking if a returned `Option` returns `Some` and extracting the value. If the assigned value is the `Some` variant, the value from the `Option` is placed into the `path` variable and the code inside the braces is executed. If the assigned value is the `None` variant, the code in the braces is not executed. This gives us a very clean way to check that the argument has been provided. `run_all` returns `Result<(), Box<dyn Error>>` as well so we will directly return the result if we execute; if not, we return the `Err` variant for our result, which is a `Box`ed `SimpleError`. Note that line 10 does not start with `return`. Also note that there is no semicolon. Rust automatically returns the value of the last expression in a function. A semicolon literally takes the value of the previous expression, discards its, and evaluates to `()`. By omitting the semicolon, the last expression is `Err(Box::new(SimpleError::new("No input path provided")))`, and is thus returned.